---
layout: post
title:  "Java并发：多线程中的局部变量"
date:   2019-07-11 16:08:00 +0200
categories: 并发
excerpt: 多线程的局部变量并不会造成线程安全问题。重点在于深度递归的栈溢出问题
tagg: Java
---

# 多线程中的局部变量

多线程的局部变量并不会造成线程安全问题。重点在于深度递归的栈溢出问题。
## 代码执行
代码怎么执行的在学校学的够清楚了。
![](https://note.youdao.com/yws/public/resource/aab7147570c5edbb8c0c3eda4018495b/xmlnote/BD58626D5B0E45BE9D652139AC55F223/18377)

## 局部变量在哪
每个方法在调用栈里都有自己的独立空间，称为**栈帧**，每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，**栈帧和方法是同生共死的**。

**局部变量就是放到了调用栈里。**

![](https://note.youdao.com/yws/public/resource/aab7147570c5edbb8c0c3eda4018495b/xmlnote/8F08D27E47E0447F8E9C626E285932FB/18387)

## 多线程的局部变量

**每个线程都有自己独立的调用栈**，所以不会引起线程安全问题

## 局部变量的递归

我觉得我写这个笔记的重点其实是这里。

**当递归很深的时候，可能会导致栈溢出。**

**原因**：

因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。

**解决方法**：
- 不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；
- 限制递归次数；
- 使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，**Java没有尾递归优化**。

<br /><br /><br /><br />
> github: https://github.com/Hikiy  
> 作者：Hiki  
> 创建日期：2019.07.11  
> 更新日期：2019.07.11
